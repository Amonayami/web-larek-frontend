# Проектная работа "Веб-ларек"

## Содержание

- [О проекте](#о-проекте)
- [Установка и запуск](#установка-и-запуск)
- [Сборка](#сборка)
- [Типизация](#типизация)
- [Архитектура приложения](#архитектура-приложения)
  - [Базовый код](#базовый-код)
  - [Слой данных (Model)](#слой-данных-model)
  - [Слой представления (View)](#слой-представления-view)
  - [Слой коммуникации (Presenter)](#слой-коммуникации-presenter)

## О проекте

Стек: `HTML` , `SCSS` , `TS` , `Webpack`

Структура проекта:

- `src` — исходные файлы проекта
- `src/components` — JS компоненты
- `src/components/base` — базовый код
- `src/components/models` — модели данных
- `src/components/view` — отображение интерфейса

Важные файлы:

- `src/pages/index.html` — HTML-файл главной страницы
- `src/types/index.ts` — файл с типами
- `src/index.ts` — точка входа приложения
- `src/scss/styles.scss` — корневой файл стилей
- `src/utils/constants.ts` — файл с константами
- `src/utils/utils.ts` — файл с утилитами

## Установка и запуск

Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```

## Сборка

```
npm run build
```

или

```
yarn build
```

## Типизация

Категория карточки

```ts
type CategoryType =
	| 'другое'
	| 'софт-скил'
	| 'дополнительное'
	| 'кнопка'
	| 'хард-скил';
```

Тип оплаты заказа

```ts
type PaymentType = 'online' | 'cash';
```

События приложения, которые может обрабатывать EventEmitter

```ts
type AppEvent =
	| 'card:select'
	| 'modal:open'
	| 'basket:add'
	| 'basket:open'
	| 'card:deselect'
	| 'basket:submit'
	| 'order:submit'
	| 'order:confirm'
	| 'order:contact'
	| 'order:success';
```

Интерфейс карточки товара

```ts
interface ICard {
	id: string;
	description: string;
	image: string;
	title: string;
	category: CategoryType;
	price: number;
}
```

Коллекция карточек

```ts
interface ICardsData {
	cards: ICard[];
	preview: string | null;
}
```

Состояние корзины

```ts
interface ICartData {
	cards: ICard[];
	price: number;
}
```

Информация о заказе

```ts
interface IOrderData {
	payment: PaymentType;
	address: string;
	email: string;
	phone: string;
}
```

Представление карточки на главной страницы

```ts
export type TMain = Pick<ICard, 'category' | 'title' | 'image' | 'price'>;
```

Представление карточки в модальном окне

```ts
export type TCardModal = Pick<
	ICard,
	'category' | 'title' | 'description' | 'image' | 'price'
>;
```

Представление карточки в корзине

```ts
export type TCartModal = Pick<ICard, 'title' | 'price'>;
```

Данные для формы оформления заказа (этап выбора способа и адреса)

```ts
export type TOrderModal = Pick<IOrder, 'payment' | 'address'>;
```

Данные для формы ввода контактов (этап контактной информации)

```ts
export type TContactModal = Pick<IOrder, 'email' | 'phone'>;
```

## Архитектура приложения
Код приложения разделен на слои согласно парадигме MVP:
- слой представления, отвечает за отображение данных
- слой данных, отвечает за хранение и изменение данных
- презентер, отвечает за связь представления и данных

### Базовый код
#### Класс Api
Класс для взаимодействия с сервером через HTTP-запросы
- Поддерживает методы `GET`, `POST`, `PUT`, `DELETE`
- Автоматически устанавливает заголовок `Content-Type: application/json`
- Обрабатывает ответы: возвращает `JSON` при успехе или ошибку при неудаче
Используется для получения и отправки данных в API

#### Класс EventEmitter
Класс EventEmitter реализует событийный брокер — механизм подписки и оповещения между компонентами

**Основной функционал:**
- Позволяет подписываться на события (`on`), отписываться (`off`), инициализировать события (`emit`)
- Поддерживает шаблонные подписки с использованием регулярных выражений
- Метод `trigger` возвращает коллбэк, автоматически вызывающий `emit`
- Метод `onAll` подписывает на все события
- Метод `offAll` удаляет все подписки

Используется для организации событийного взаимодействия между частями приложения

### Слой данных (Model)
Отвечает за хранение и обработку данных приложения. Модели не взаимодействуют напрямую с `DOM` и не занимаются отображением. Все классы моделей принимают `EventEmitter` в качестве зависимости и используют его для уведомления других компонентов об изменениях состояния

#### Класс CardsModel
Класс `CardsModel` реализует интерфейс `ICardsData` и представляет собой модель данных для управления списком товаров (карточек) в приложении

**Назначение:**\
Обеспечивает хранение, доступ и выбор карточек товаров, полученных с сервера. Используется для передачи данных в представление (`View`) и взаимодействия с другими частями приложения по архитектуре MVP

**Основной функционал:**
- Хранит список карточек (`_cards`), полученных с сервера при инициализации
- Отслеживает выбранную карточку (`_preview`) для показа детальной информации в модальном окне
- Метод `getCard(id)` позволяет получить карточку по её идентификатору — используется, например, для отображения содержимого модального окна
- Метод `hasSelected()` проверяет, выбрана ли карточка — может использоваться для проверки, был ли добавлен товар в корзину

#### Класс CartModel
Класс `CartModel` реализует интерфейс `ICartData` и представляет собой модель данных для управления корзиной товаров в приложении

**Назначение:**\
Отвечает за хранение списка товаров, добавленных в корзину, а также предоставляет методы для расчёта общей стоимости и управления содержимым корзины. Используется в архитектуре MVP для взаимодействия с представлением корзины и оформления заказа

**Основной функционал:**
- Хранит список товаров в корзине (`items`), добавленных пользователем
- Метод `getTotalPrice()` возвращает общую стоимость всех товаров в корзине
- Метод `addItem(item)` добавляет товар в корзину
- Метод `deleteItem(id)` удаляет товар из корзины по идентификатору
- Метод `hasItems()` проверяет, содержит ли корзина хотя бы один товар — используется, например, перед переходом к оформлению заказа

#### Класс OrderModel
Класс `OrderModel` реализует интерфейс `IOrderData` и представляет собой модель данных для оформления заказа в приложении

**Назначение:**\
Хранит и управляет данными, необходимыми для оформления заказа, такими как способ оплаты, адрес доставки и контактная информация. Используется в архитектуре MVP для передачи данных между формой заказа и другими компонентами приложения

**Основной функционал:**
- Сохраняет информацию о заказе: способ оплаты (`payment`), адрес доставки (`address`), а также контактные данные email и телефон
- Метод `setPayment(type)` устанавливает способ оплаты
- Метод `setAddress(address)` сохраняет адрес доставки
- Метод `setContactInfo(email, phone)` устанавливает контактную информацию пользователя
- Метод `isValid()` проверяет, заполнены ли все необходимые поля для оформления заказа — может использоваться перед отправкой данных на сервер

### Слой представления (View)
Отвечает за отображение интерфейса. Представления не хранят состояние, а только визуализируют переданные данные и обрабатывают события пользователя. Все классы `View` принимают `EventEmitter` в качестве зависимости для работы с событиями

### Класс ModalView
Класс `ModalView` — универсальный контейнер для модального контента

**Назначение:**\
Открывает модальные окна с любым вложенным контентом: карточкой, корзиной, формой заказа, формой контактов, сообщением об успехе

**Основной функционал:**
- Метод `open(content: HTMLElement)` — отображает переданный HTML внутри модального окна
- Метод `close()` — закрывает модальное окно, генерирует событие `modal:close`
- Метод `bindClose(handler: () => void)` — назначает обработчик на кнопку закрытия
- Метод `render(content: HTMLElement)` — вставляет HTML в контейнер

**Особенности:**\
- Абстрагирован от типа содержимого: может отрисовать как карточку, так и форму
- Работает с универсальными компонентами (например, `CardView`) через `render`

### Класс CardView
Класс `CardView` отвечает за отображение карточки товара в разных контекстах: на главной странице, в модальном окне и в корзине

**Назначение:**\
Универсальный компонент карточки товара. Отрисовывает HTML-элемент по переданному шаблону и данным карточки. Используется для трёх разных представлений карточки, передавая в конструктор соответствующий шаблон и параметры конфигурации. Обрабатывает пользовательские действия: клик по карточке, клик по кнопке «удалить», клик по кнопке «в корзину»

**Основной функционал:**
- Конструктор `constructor(template: HTMLTemplateElement, emitter: EventEmitter)` — принимает HTML-шаблон карточки и экземпляр EventEmitter
- Метод `render(data: TMain | TCardModal | TCartModal, options?: { removable?: boolean; addable?: boolean })` — генерирует карточку на основе переданных данных
- Если передан флаг `removable: true` — добавляет кнопку удаления
- Если передан флаг `addable: true` — добавляет кнопку добавления в корзину
- Метод `bindClick(handler: (id: string) => void)` — назначает обработчик клика по карточке. Генерирует событие `card:select` с `id` товара
- Метод `bindDelete(handler: (id: string) => void)` — назначает обработчик кнопки удаления (если отрисована). Генерирует событие `card:deselect`
- Метод `bindAdd(handler: (id: string) => void)` — назначает обработчик кнопки добавления в корзину (если отрисована). Генерирует событие `basket:add`

**Особенности:**
- Один класс — три представления карточки: галерея, модальное окно, корзина
- Разделение логики реализуется через параметры конструктора и метода `render`
- Не хранит состояние, работает строго в рамках слоя `View`
- Гибкость достигается за счёт параметров шаблона и опций `render`

### Класс MainView
Класс `MainView` отвечает за отображение главной страницы: галерея товаров, счётчик корзины, иконка корзины

**Назначение:**\
Управляет отображением всех карточек товаров в галерее, а также отображением и обновлением счётчика товаров в корзине. Использует `CardView` как универсальный компонент карточки

**Основной функционал:**
- Метод `renderCards(cards: TMain[], createCard: (data: TMain) => HTMLElement)` — отрисовывает карточки товаров, используя универсальный `CardView`, переданный через функцию `createCard`
- Метод `renderCartCounter(count: number)` — обновляет визуальное значение счётчика корзины
- Метод `bindCartIconClick(handler: () => void)` — назначает обработчик клика по иконке корзины (`basket:open`)
- Метод `setRoot(container: HTMLElement)` — позволяет установить корневой контейнер для карточек (если он был подгружен асинхронно или динамически)

**Особенности:**
- Не зависит от шаблона карточки напрямую, используется `createCard` из `Presenter`.
- Строго отделяет визуальную часть от логики генерации карточек.
- Работает только с `DOM`-элементами, не хранит состояние.

### Класс CartView
Класс `CartView` отвечает за отображение содержимого корзины и финальной стоимости

**Назначение:**\
Отображает список товаров, добавленных в корзину, используя `CardView` с шаблоном карточки из корзины. Позволяет пользователю перейти к оформлению заказа

**Основной функционал:**
- Метод `render(items: TCartModal[], total: number, createCard: (data: TCartModal, options?: { removable?: boolean }) => HTMLElement)` — отрисовывает список карточек товаров в корзине и отображает итоговую сумму
- Метод `bindSubmit(handler: () => void)` — добавляет обработчик на кнопку «Оформить заказ». Генерирует событие `basket:submit`

**Особенности:**
- Не знает о шаблоне карточки — карточки создаются через `createCard`, переданную из презентера
- Использует флаг removable: true при рендеринге карточек — `CardView` сам отрисует кнопку удаления
- Не хранит состояние корзины, работает только с `DOM`

#### Класс OrderView
Класс `OrderView` отображает форму для ввода адреса и выбора способа оплаты

**Назначение:**\
Используется на первом этапе оформления заказа. Позволяет пользователю выбрать оплату и ввести адрес доставки

**Основной функционал:**
- Метод `render(data: TOrderModal)` — визуализирует форму ввода данных типа `TOrderModal`
- Метод `bindChange(handler: (field: keyof TOrderModal, value: string) => void)` — обрабатывает изменение данных формы
- Метод `bindSubmit(handler: () => void)` — добавляет обработчик отправки формы и вызывает событие `order:submit`
- Метод `showError(field: keyof TOrderModal, message: string)` — отображает сообщение об ошибке рядом с полем формы (например, «Введите корректный адрес»)
- Метод `hideError(field: keyof TOrderModal)` — скрывает сообщение об ошибке для указанного поля

#### Класс ContactView
Класс `ContactView` отвечает за отображение формы ввода контактной информации

**Назначение:**\
Используется на втором этапе оформления заказа. Позволяет пользователю ввести email и номер телефона

**Основной функционал:**
- Метод `render(data: TContactModal)` — отображает форму на основе типа `TContactModal`
- Метод `bindChange(handler: (field: keyof TContactModal, value: string) => void)` — обрабатывает изменение контактных данных
- Метод `bindSubmit(handler: () => void)` — добавляет обработчик отправки формы и вызывает событие `order:success`
- Метод `showError(field: keyof TContactModal, message: string)` — отображает сообщение об ошибке рядом с полем (email или телефон)
- Метод `hideError(field: keyof TContactModal)` — скрывает сообщение об ошибке

#### Класс SuccessOrderView
Класс `SuccessOrderView` представляет окно с сообщением об успешном оформлении заказа

**Назначение:**\
Отображает финальное сообщение пользователю после успешной отправки заказа. Используется для подтверждения оформления и завершения пользовательского сценария покупки в интерфейсе

**Основной функционал:**
- Метод `render(total: number)` — отображает сообщение об успешном оформлении заказа с итоговой суммой

### Слой коммуникации (Presenter)
Обеспечивает взаимодействие между слоем данных (`Model`) и слоем отображения (`View`). Обрабатывает события пользователя, изменяет состояние данных и инициирует соответствующее обновление интерфейса. Все подписки и логика взаимодействия компонентов сосредоточены в этом классе. Роль презентера выполняет модуль index.ts

**Назначение:**
- Инициализирует все представления (`CardView`, `CardPreviewView`, `CartView`, `OrderView`, `ContactView`, `SuccessOrderView`) и модели (`CardsModel`, `CartModel`, `OrderModel`)
- Подписывается на события `EventEmitter`, обрабатывает пользовательские действия и обновляет представления

**Основной функционал:**\
Отвечает за следующие сценарии взаимодействия:
- выбор карточки на главной странице (`card:select`)
- отображение детальной информации о товаре (`modal:open`)
- добавление товара в корзину (`basket:add`)
- открытие и отображение содержимого корзины (`basket:open`)
- удаление товара из корзины (`card:deselect`)
- переход к оформлению заказа (`basket:submit`)
- ввод и валидация адреса и способа оплаты (`order:submit`)
- ввод и валидация контактной информации (`order:success`)
- завершение оформления заказа и отображение сообщения об успехе (`order:success`)

Обработчики событий:
- `handleCardSelect(id: string)` — обработчик события выбора карточки. Отвечает за вызов методов представления для открытия модального окна с подробной информацией о выбранной карточке и при необходимости запрос данных из модели
- `handleAddToCart()` — обработчик события добавления товара в корзину. Вызывает методы модели для обновления содержимого корзины и методы представления для обновления интерфейса корзины
- `handleOpenCart()` — обработчик события открытия корзины. Использует методы представления для отображения текущего состояния корзины, полученного из модели
- `handleDeleteFromCart(id: string)` — обработчик удаления товара из корзины. Вызывает метод модели для удаления товара по id и обновляет отображение корзины через методы представления
- `handleOrderSubmit()` — обработчик начала оформления заказа. Отвечает за отображение формы ввода данных заказа через методы соответствующего представления
- `handleOrderFormChange(field, value)` — обработчик изменения полей формы заказа. Передаёт новые данные в модель для актуализации состояния заказа.
- `handleOrderConfirm()` — обработчик подтверждения данных заказа. Проверяет корректность введённых данных через методы модели, и при успешной валидации запускает отображение следующей части формы (контактной информации)
- `handleContactFormChange(field, value)` — обработчик изменения контактной информации в форме. Обновляет данные в модели
- `handleOrderFinish()` — обработчик завершения оформления заказа. Обеспечивает финальное подтверждение и вывод сообщения об успешном оформлении через методы представления

Особенности:
- Централизует обработку всех пользовательских сценариев
- Изолирует бизнес-логику от интерфейса и хранения данных
- Использует EventEmitter для коммуникации между слоями
